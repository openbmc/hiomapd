#pragma once

#include <vector>
#include <experimental/filesystem>
#include "pnor_partition_defs.h"

namespace fs = std::experimental::filesystem;

namespace openpower
{
namespace virtual_pnor
{

/** @brief Convert the input pnor_partition_table structure
 *         to big endian.
 *
 *  @param[in] tbl - reference to the pnor partition table
 *
 *  @returns pointer to newly allocated big endian table. Caller to
 *           deallocate memory by calling free() on the returned pointer.
 */
pnor_partition_table*  endianFixup(const pnor_partition_table& tbl);

namespace details
{

/** @brief Compute XOR-based checksum, by XORing consecutive words
 *         in the input data. Input must be aligned to word boundary.
 *
 *  @param[in] data - input data on which checksum is computed
 *  @param[in] size - size of data in bytes.
 *
 *  @returns computed checksum
 */
uint32_t checksum(const void* data, size_t size);

} // namespace details

namespace partition
{

/** @class Table
 *  @brief Generates virtual PNOR partition table.
 *
 *  Generates virtual PNOR partition table upon construction. Reads
 *  the PNOR information generated by this tool :
 *  github.com/openbmc/openpower-pnor-code-mgmt/blob/master/generate-squashfs,
 *  which generates a minimalistic table-of-contents (toc) file and
 *  individual files to represent various partitions that are of interest -
 *  these help form the "virtual" PNOR, which is typically a subset of the full
 *  PNOR image.
 *  These files are stored in a well-known location on the PNOR.
 *  Based on this information, this class prepares the partition table whose
 *  structure is as outlined in pnor_partition.h.
 *
 *  The vrtual PNOR supports 4KB erase blocks - partitions must be aligned to
 *  this size.
 */
class Table
{
    public:
        /** @brief Constructor accepting the path of the directory
         *         that houses the PNOR partition files.
         *
         *  @param[in] directory - path of the directory housing PNOR partitions
         */
        Table(fs::path&& directory);

        Table();
        Table(const Table&) = delete;
        Table& operator=(const Table&) = delete;
        Table(Table&&) = delete;
        Table& operator=(Table&&) = delete;
        ~Table();

        /** @brief Return size of partition table
         *
         *  @returns size_t - size of partition table in blocks
         */
        size_t size() const
        {
            return szBlocks;
        }

        /** @brief Return pointer to a big-endian partition table. Caller
         *         to deallocate memory be calling free() on the returned
         *         pointer.
         *
         *  The host needs the partion table in big-endian.
         *
         *  @returns pointer to partition table. NULL if table not created
         */
        pnor_partition_table* getBE() const
        {
            return tbl ? endianFixup(*tbl) : nullptr;
        }

        /** @brief Return pointer to a little-endian partition table
         *
         *  @returns const pointer to partition table
         */
        const pnor_partition_table* const getLE() const
        {
            return tbl;
        }

        /** @brief Return partition corresponding to PNOR offset, the offset
         *         is within returned partition.
         *
         *  @param[in] offset - PNOR offset in bytes
         *
         *  @returns const pointer to partition_entry
         */
        const pnor_partition* partition(const off_t offset) const;

    private:
        /** @brief Prepares a vector of PNOR partition structures.
         */
        void preparePartitions();

        /** @brief Prepares the PNOR header.
         */
        void prepareHeader();

        /** @brief Allocate memory to hold the partion table. Determine the
         *         amount needed based on the partition files in the toc file.
         *
         *  @param[in] tocFile - Table of contents file path.
         */
        void allocateMemory(const fs::path& tocFile);

        /** @brief Populate fields related to sizes for the input
         *         pnor_partition structure.
         *
         *  @param[in/out] part - pnor_partition structure
         *  @param[in] size - size of partition in bytes
         */
        void writeSizes(pnor_partition& part, const size_t size);

        /** @brief Populate userdata bits for the input
         *         pnor_partition structure.
         *
         *  @param[in/out] part - pnor_partition structure
         *  @param[in] data - string having userdata fields in a
         *             comma-separated line.
         */
        void writeUserdata(pnor_partition& part, const std::string& data);

        /** @brief Populate the name and id fields for the input
         *         pnor_partition structure.
         *
         *  @param[in/out] part - pnor_partition structure
         *  @param[in] name - partition name
         *  @param[id] id - partition id
         */
        void writeNameAndId(pnor_partition& part, const std::string& name,
                            const std::string& id);

        /** @brief Populate default/unused fields for the input
         *         pnor_partition structure.
         *
         *  @param[in/out] part - pnor_partition structure
         */
        void writeDefaults(pnor_partition& part);

        /** @brief Size of the PNOR partition table -
         *         sizeof(pnor_partition_table) +
         *         (no. of partitions * sizeof(pnor_partition)),
         *         measured in erase-blocks.
         */
        size_t szBlocks;

        /** @brief Size of virtual PNOR image, measured in erase-blocks */
        size_t imgBlocks;

        /** @brief Partition table header */
        pnor_partition_table* tbl;

        /** @brief Directory housing generated PNOR partition files */
        fs::path directory;

        /** @brief Number of partitions */
        size_t numParts;
};

} // namespace partition
} // namespace virtual_pnor
} // namespace openpower
